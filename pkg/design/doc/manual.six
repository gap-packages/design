C design.tex 1. Design
S 1.1. Installing the DESIGN Package
S 1.2. Loading DESIGN
S 1.3. The structure of a block design in DESIGN
I 1.3. block design
I 1.3. binary block design
S 1.4. Example of the use of DESIGN
C parameters.tex 2. Information from block design parameters
S 2.1. Information from $t$-design parameters
I 2.1. t-design
F 2.1. TDesignLambdas
F 2.1. TDesignLambdaMin
F 2.1. TDesignIntersectionTriangle
F 2.1. SteinerSystemIntersectionTriangle
F 2.1. TDesignBlockMultiplicityBound
F 2.1. ResolvableTDesignBlockMultiplicityBound
S 2.2. Block intersection polynomials
F 2.2. BlockIntersectionPolynomial
F 2.2. BlockIntersectionPolynomialCheck
C construct.tex 3. Constructing block designs
S 3.1. Functions to construct block designs
F 3.1. BlockDesign
F 3.1. BlockDesign
F 3.1. AGPointFlatBlockDesign
F 3.1. PGPointFlatBlockDesign
F 3.1. WittDesign
F 3.1. DualBlockDesign
F 3.1. ComplementBlocksBlockDesign
F 3.1. DeletedPointsBlockDesign
F 3.1. DeletedBlocksBlockDesign
F 3.1. AddedPointBlockDesign
F 3.1. AddedPointBlockDesign
F 3.1. AddedBlocksBlockDesign
F 3.1. DerivedBlockDesign
I 3.1. derived design
F 3.1. ResidualBlockDesign
I 3.1. residual design
F 3.1. TDesignFromTBD
C basic.tex 4. Determining basic properties of block designs
S 4.1. The functions for basic properties
F 4.1. IsBlockDesign
F 4.1. IsBinaryBlockDesign
F 4.1. IsSimpleBlockDesign
F 4.1. IsConnectedBlockDesign
F 4.1. BlockDesignPoints
F 4.1. NrBlockDesignPoints
F 4.1. BlockDesignBlocks
F 4.1. NrBlockDesignBlocks
F 4.1. BlockSizes
F 4.1. BlockNumbers
F 4.1. ReplicationNumber
F 4.1. PairwiseBalancedLambda
F 4.1. TSubsetLambdasVector
F 4.1. AllTDesignLambdas
F 4.1. AffineResolvableMu
C efficiency.tex 5. Matrices and efficiency measures for block designs
S 5.1. Matrices associated with a block design
F 5.1. PointBlockIncidenceMatrix
F 5.1. ConcurrenceMatrix
F 5.1. InformationMatrix
S 5.2. The function BlockDesignEfficiency
F 5.2. BlockDesignEfficiency
F 5.2. BlockDesignEfficiency
F 5.2. BlockDesignEfficiency
C autiso.tex 6. Automorphism groups and isomorphism testing for block designs
S 6.1. Computing automorphism groups
F 6.1. AutGroupBlockDesign
S 6.2. Testing isomorphism
F 6.2. IsIsomorphicBlockDesign
F 6.2. BlockDesignIsomorphismClassRepresentatives
C classify.tex 7. Classifying block designs
S 7.1. The function BlockDesigns
F 7.1. BlockDesigns
C sls.tex 8. Classifying semi-Latin squares
S 8.1. Semi-Latin squares and SOMAs
I 8.1. semi-Latin square
I 8.1. SOMA
S 8.2. The function SemiLatinSquareDuals
F 8.2. SemiLatinSquareDuals
F 8.2. SemiLatinSquareDuals
F 8.2. SemiLatinSquareDuals
F 8.2. SemiLatinSquareDuals
C partition.tex 9. Partitioning block designs
S 9.1. Partitioning a block design into block designs
F 9.1. PartitionsIntoBlockDesigns
S 9.2. Computing resolutions
F 9.2. MakeResolutionsComponent
F 9.2. MakeResolutionsComponent
C xmlio.tex 10. XML I/O of block designs
S 10.1. Writing lists of block designs and their properties in XML-format
F 10.1. BlockDesignsToXMLFile
F 10.1. BlockDesignsToXMLFile
F 10.1. BlockDesignsToXMLFile
S 10.2. Reading lists of block designs in XML-format
F 10.2. BlockDesignsFromXMLFile
